"""
Translates a JSON file containing the CFG of a smart contract to the Coq representation of the FORYU project
(https://github.com/costa-group/foryu/tree/main)
JSON are obtained using solc:
$ solc file_standard_input.json --standard-json --pretty-json > cfg.json
"""

import json
import pprint
import re
import sys
from datetime import datetime

"""
Layout of the JSON file
{
    'contracts':{
        'name.sol':{
          'entry'
            'yulCFGJson':{
                'entry1':{
                    'blocks': [],
                    'functions': {
                        'f1': ...
                        'f2': ...
                    } 
                },
                
                'entry2':{
                    'blocks': [],
                    'functions': {
                        'f1': ...
                        'f2': ...
                    } 
                } 
            } 
            ...
        }
    }
    
    'errors':...
}
"""


class JSON_Smart_Contract:

    def __init__(self, path):
        self.sc_main_filename, self.flat_d = self.process_json(path)
        self.liveness = {}

    def gen_name(self, prefix, fname=None):
        """ Generates a name from the prefix """
        if fname is None:
            return "__".join(prefix).replace(".", "_")
        return "__".join(prefix+[fname]).replace(".", "_")


    def process_blocks(self, blocks, prefix):
        """ Generates a main function from an objects blocks """
        if blocks:
            return {self.gen_name(prefix + ['entry']):
                        {'arguments': [],
                         'blocks': blocks,
                         'entry': blocks[0]['id'],
                         'numReturns': 0}
                    }
        return {}

    def expand_function_names_instr(self, i, prefix):
        """ Expand the name in a function call (updates the parameter 'i') """
        if i['op'] not in JSON_Smart_Contract.evm_opcode and i['op'] not in ['PhiFunction', 'LiteralAssignment']:
            # It's a function call
            i['op'] = self.gen_name(prefix, i['op'])

    def expand_function_names_instrs(self, instructions, prefix):
        """ Expand the name in a function call (updates the parameter 'instructions') """
        for i in instructions:
            self.expand_function_names_instr(i, prefix)

    def expand_function_names_block(self, b, prefix):
        """ Expand the name in a function call (updates the parameter 'b') """
        self.expand_function_names_instrs(b['instructions'], prefix)

    def expand_function_names_blocks(self, blocks, prefix):
        """ Expand the name in a function call (updates the parameter 'blocks') """
        for b in blocks:
            self.expand_function_names_block(b, prefix)

    def expand_function_names_def(self, functions: dict, prefix):
        """ Expand the name in a function call and definition (updates the parameter 'functions' """
        fnames = list(functions.keys())
        for fname in fnames:
            fdef = functions[fname]
            functions.pop(fname)
            self.expand_function_names_blocks(fdef['blocks'], prefix)
            expand_fname = self.gen_name(prefix, fname)
            functions[expand_fname] = fdef

    def process_object(self, d: dict, prefix: list):
        """ Extracts all the entries in an object (and recursively subobjects), generating functions for each one """
        r = {}
        for object_name in d:
            if object_name == 'type':
                continue

            subobj = d[object_name]['subObjects']
            if subobj:
                r.update(self.process_object(subobj, prefix + [object_name]))

            functions = d[object_name]['functions']
            self.expand_function_names_def(functions, prefix + [object_name])
            r.update(functions)  # TODO: Do we need to rename the functions in different objects? (prefix)

            blocks = d[object_name]['blocks']
            if blocks:
                self.expand_function_names_blocks(blocks, prefix + [object_name])
                r.update(self.process_blocks(blocks, prefix + [object_name]))

        return r

    def process_json(self, path):
        """ Processes a JSON file as generated by solc and generates a flat dictionary of function definitions """
        with open(path, 'r', encoding="utf-8") as f:
            data = json.load(f)

        scs = data['contracts']
        flat_d = {}
        sc_main_filename = None
        for sc_filename in scs:
            sc = scs[sc_filename]
            if not sc_main_filename:
                sc_main_filename = sc_filename
            for comp in sc:
                yul_cfg = sc[comp]['yulCFGJson']
                assert yul_cfg['type'] == 'Object'
                flat_d.update(self.process_object(yul_cfg, [sc_filename, comp]))

        return sc_main_filename, flat_d

    def translate_block_id(self, block_id):
        """ Extracts the block number from the string 'BlockN' """
        return int(block_id[5:])

    def is_var(self, var: str):
        m = re.match(r"^v([0-9]+)$", var)
        return m is not None

    def translate_var(self, var: str):
        """ Translates a variable like 'v0' into '0%nat' """
        m = re.match(r"^v([0-9]+)$", var)
        assert m is not None
        var_i = int(m[1])
        return f"{var_i}%nat"

    def is_constant(self, v: str):
        m = re.match(r"^0x[0-9A-Fa-f]+$", v)
        return m is not None

    def translatate_constant(self, v: str) -> str:
        """ Translates a constant value, remains the same """
        assert self.is_constant(v), f"{v} no es un valor"
        return v

    def translate_var_list(self, var_list):
        """ Returns a string with the Coq list of variable indices
            ["v0", "v1"]  --> "0%nat; 1%nat"
        """
        vars_i = []
        for var in var_list:
            var_i = int(var[1:])  # To check they are integers
            assert var_i >= 0
            vars_i.append(f"{var_i}%nat")
        return "; ".join(vars_i)

    def translate_var_constant_list(self, vc_list):
        """ Translate a list containing variables or constant values using
            * inl Variable
            * inr Constant
        """
        elements = []
        for vc in vc_list:
            if self.is_var(vc):
                elements.append(f"inl {self.translate_var(vc)}")
            else:
                elements.append(f"inr {self.translatate_constant(vc)}")
        return "; ".join(elements)

    def generate_phi(self, phis, entries):
        # TODO: FIXME
        assert not entries or phis, f"A block without entry information has phi_functions: {phis}"
        assert len(entries) in [0, 2], f"A block with more than 1 o >2 entries: {entries}"
        if len(entries) == 0:
            return "EVMBlock.PhiInfoD.empty"

        # 2 entries
        block0 = f"{self.translate_block_id(entries[0])}%nat"
        block1 = f"{self.translate_block_id(entries[1])}%nat"
        phi_d = {block0: [], block1: []}
        for phi in phis:
            # {"in": ["v18", "v23"], "op": "PhiFunction", "out": ["v24"]}
            assert len(phi['out']) == 1, f"PhiFunction with more than one out variable {phi}"
            dest_v = self.translate_var(phi['out'][0])
            [value_0, value_1] = self.translate_var_constant_list(phi['in']).split('; ')
            phi_d[block0].append(f"({dest_v}, {value_0})")
            phi_d[block1].append(f"({dest_v}, {value_1})")

        # Generate Coq text for PhiInfo
        coq_block0 = '; '.join(phi_d[block0])
        coq_block1 = '; '.join(phi_d[block1])
        trans = f"fun blockid => if BlockID.eqb blockid {block0} then [{coq_block0}] else if BlockID.eqb blockid {block1} then [{coq_block1}] else []"
        return trans

    def translate_exit_info(self, exit):
        # TODO: FIXME
        if exit['type'] in ['Terminated', "MainExit"]:
            return "EVMBlock.ExitInfoD.Terminated"
        elif exit['type'] == 'FunctionReturn':
            # JSON: { "returnValues": ["v10"], "type": "FunctionReturn" }
            # Coq:  ReturnBlock (return_values : list SimpleExprD.t) (* I believe they are always vars *)
            return f"EVMBlock.ExitInfoD.ReturnBlock [{self.translate_var_constant_list(exit['returnValues'])}]"
        elif exit['type'] == 'ConditionalJump':
            # JSON: {'cond': 'v2', 'targets': ['Block2', 'Block1'], 'type': 'ConditionalJump'}
            # Coq:  ConditionalJump (cond_var : YULVariable.t) (target_if_true : BlockID.t) (target_if_false : BlockID.t)
            var = self.translate_var(exit['cond'])
            assert len(exit['targets']) == 2
            target_true = self.translate_block_id(exit['targets'][0])
            target_false = self.translate_block_id(exit['targets'][1])
            return f"EVMBlock.ExitInfoD.ConditionalJump {var} {target_true}%nat {target_false}%nat"
        elif exit['type'] == 'Jump':
            # JSON: {'targets': [BlockID], 'type': 'Jump' }
            # Coq:  Jump (target : BlockID.t)
            assert len(exit['targets']) == 1, f"JUMP exit block with more than one target: {exit}"
            target = self.translate_block_id(exit['targets'][0])
            return f"EVMBlock.ExitInfoD.Jump {target}%nat"
        else:
            raise Exception(f'Exit_info not supported: <<{exit}>>')

    evm_opcode = {
        # TODO: FIXME
        'stop': 'EVM_opcode.STOP',
        'add': 'EVM_opcode.ADD',
        'sub': 'EVM_opcode.SUB',
        'mul': 'EVM_opcode.MUL',
        'div': 'EVM_opcode.DIV',
        'sdiv': 'EVM_opcode.SDIV',
        'mod': 'EVM_opcode.MOD',
        'smod': 'EVM_opcode.SMOD',
        'exp': 'EVM_opcode.EXP',
        'not': 'EVM_opcode.NOT',
        'lt': 'EVM_opcode.LT',
        'gt': 'EVM_opcode.GT',
        'slt': 'EVM_opcode.SLT',
        'sgt': 'EVM_opcode.SGT',
        'eq': 'EVM_opcode.EQ',
        'iszero': 'EVM_opcode.ISZERO',
        'and': 'EVM_opcode.AND',
        'or': 'EVM_opcode.OR',
        'xor': 'EVM_opcode.XOR',
        'byte': 'EVM_opcode.BYTE',
        'shl': 'EVM_opcode.SHL',
        'shr': 'EVM_opcode.SHR',
        'sar': 'EVM_opcode.SAR',
        'addmod': 'EVM_opcode.ADDMOD',  # Not in semanticTests
        'mulmod': 'EVM_opcode.MULMOD',
        'signextend': 'EVM_opcode.SIGNEXTEND',
        'keccak256': 'EVM_opcode.KECCAK256',
        'pop': 'EVM_opcode.POP',
        'mload': 'EVM_opcode.MLOAD',
        'mstore': 'EVM_opcode.MSTORE',
        'mstore8': 'EVM_opcode.MSTORE8',
        'sload': 'EVM_opcode.SLOAD',
        'sstore': 'EVM_opcode.SSTORE',
        'tload': 'EVM_opcode.TLOAD',
        'tstore': 'EVM_opcode.TSTORE',
        'msize': 'EVM_opcode.MSIZE',  # Not in semanticTests
        'gas': 'EVM_opcode.GAS',
        'address': 'EVM_opcode.ADDRESS',
        'balance': 'EVM_opcode.BALANCE',
        'selfbalance': 'EVM_opcode.SELFBALANCE',
        'caller': 'EVM_opcode.CALLER',
        'callvalue': 'EVM_opcode.CALLVALUE',
        'calldataload': 'EVM_opcode.CALLDATALOAD',
        'calldatasize': 'EVM_opcode.CALLDATASIZE',
        'calldatacopy': 'EVM_opcode.CALLDATACOPY',
        'codesize': 'EVM_opcode.CODESIZE',
        'codecopy': 'EVM_opcode.CODECOPY',
        'extcodesize': 'EVM_opcode.EXTCODESIZE',
        'extcodecopy': 'EVM_opcode.EXTCODECOPY',
        'returndatasize': 'EVM_opcode.RETURNDATASIZE',
        'returndatacopy': 'EVM_opcode.RETURNDATACOPY',
        'mcopy': 'EVM_opcode.MCOPY',
        'extcodehash': 'EVM_opcode.EXTCODEHASH',
        'create': 'EVM_opcode.CREATE',
        'create2': 'EVM_opcode.CREATE2',
        'call': 'EVM_opcode.CALL',
        'callcode': 'EVM_opcode.CALLCODE',  # Not in semanticTests
        'delegatecall': 'EVM_opcode.DELEGATECALL',
        'staticcall': 'EVM_opcode.STATICCALL',
        'return': 'EVM_opcode.RETURN',
        'revert': 'EVM_opcode.REVERT',
        'selfdestruct': 'EVM_opcode.SELFDESTRUCT',
        'invalid': 'EVM_opcode.INVALID',
        'log0': 'EVM_opcode.LOG0',
        'log1': 'EVM_opcode.LOG1',
        'log2': 'EVM_opcode.LOG2',
        'log3': 'EVM_opcode.LOG3',
        'log4': 'EVM_opcode.LOG4',
        'chainid': 'EVM_opcode.CHAINID',
        'basefee': 'EVM_opcode.BASEFEE',
        'blobbasefee': 'EVM_opcode.BLOBBASEFEE',
        'origin': 'EVM_opcode.ORIGIN',
        'basprice': 'EVM_opcode.GASPRICE',
        'blockhash': 'EVM_opcode.BLOCKHASH',
        'blobhash': 'EVM_opcode.BLOBHASH',
        'coinbase': 'EVM_opcode.COINBASE',
        'timestamp': 'EVM_opcode.TIMESTAMP',
        'number': 'EVM_opcode.NUMBER',
        'difficulty': 'EVM_opcode.DIFFICULTY',  # obsolete from Paris, now uses PREVRANDAO. Not in semanticTests
        'prevrandao': 'EVM_opcode.PREVRANDAO',
        'gaslimit': 'EVM_opcode.GASLIMIT',
        # Yul-specific instructions (https://docs.soliditylang.org/en/latest/yul.html#datasize-dataoffset-datacopy)
        'memoryguard': 'EVM_opcode.MEMORYGUARD',
        'datasize': 'EVM_opcode.DATASIZE',
        'dataoffset': 'EVM_opcode.DATAOFFSET',
        'datacopy': 'EVM_opcode.DATACOPY',
    }

    def translate_instruction(self, instruction):
        # {'in': ['0x00', '0x00'], 'op': 'revert', 'out': []}
        #    Record t : Type := {
        #     input : list SimpleExprD.t;
        #     output : list YULVariable.t; (* Output variables *)
        #     op : (FunctionName.t + D.opcode_t) + aux_inst_t;
        # {| EVMInstruction.input := [inr 0x2; inr 0x0202];
        #    EVMInstruction.output := [ 1%nat ];
        #    EVMInstruction.op := inl (inr EVM_opcode.MUL) |}.

        if instruction['op'] == 'PhiFunction':
            raise ValueError('PhiFunctions should be removed before translating instructions')
        elif instruction['op'] == 'LiteralAssignment':
            instr = 'inr EVMInstruction.ASSIGN'
        elif instruction['op'] in JSON_Smart_Contract.evm_opcode:
            instr = f"inl (inr {JSON_Smart_Contract.evm_opcode[instruction['op']]})"
        else:
            print(f"* function call: {instruction['op']}", file=sys.stderr)
            instr = f'inl (inl "{instruction["op"]}")'

        in_v = self.translate_var_constant_list(instruction['in'])
        out_v = self.translate_var_list(instruction['out'])

        return (f"                  {{| EVMInstruction.input := [ {in_v} ];\n"
                f"                      EVMInstruction.output := [ {out_v} ];\n"
                f"                      EVMInstruction.op := {instr}\n"
                f"                  |}}")

    def translate_instructions(self, instructions):
        return ";\n".join([self.translate_instruction(i) for i in instructions])

    def split_block(self, instructions):
        """ Split a list of instructions into PhiFunctions and real instructions """
        phi_functions = list(filter(lambda i: i['op'] == 'PhiFunction', instructions))
        instr = list(filter(lambda i: i['op'] != 'PhiFunction', instructions))
        return phi_functions, instr

    def translate_block(self, block):
        """ Generates a string representing a Coq block from a JSON block """
        template = """
                {{| EVMBlock.bid := {}%nat;
                   EVMBlock.phi_function := {};
                   EVMBlock.exit_info := {};
                   EVMBlock.instructions := [ 
    {}]
                |}}"""
        bid = self.translate_block_id(block['id'])
        phi_functions, instr = self.split_block(block['instructions'])
        phi_function = self.generate_phi(phi_functions, block.get('entries', []))
        exit_info = self.translate_exit_info(block['exit'])
        instructions = self.translate_instructions(instr)
        return template.format(bid, phi_function, exit_info, instructions)

    def translate_blocks(self, blocks):
        return ";".join([self.translate_block(b) for b in blocks])

    def translate_function(self, f_name, func):
        """ Generates the Coq representation of a function """
        template = """      {{| EVMFunction.name := "{}";
             EVMFunction.arguments := [{}];
             EVMFunction.num_outputs := {};
             EVMFunction.blocks := [
    {}
             ];
             EVMFunction.entry_block_id := {}%nat
          |}}"""
        blocks = self.translate_blocks(func['blocks'])
        arguments = self.translate_var_list(func['arguments'])
        num_outputs = func['numReturns']
        entry_block_id = self.translate_block_id(func['entry'])
        return template.format(f_name, arguments, num_outputs, blocks, entry_block_id)

    def translate_smart_contract(self):
        """Generates the Coq representation of a smart contract """
        template = """Definition sc_tr : EVMSmartContract.t :=
       {{| EVMSmartContract.name := "{}";
           EVMSmartContract.functions := [\n{}];
           EVMSmartContract.main := "{}" 
       |}}."""
        functs_coq = []
        entry_fname = None
        for f_name, func in self.flat_d.items():
            if not entry_fname:
                entry_fname = f_name
            functs_coq.append(self.translate_function(f_name, func))
        list_functs = ";\n".join(functs_coq)

        return template.format(self.sc_main_filename, list_functs, entry_fname)

    def extract_liveness_info(self):
        """ Collects all the liveness information from function's blocks """
        liveness_info = {}
        for f_name, func in self.flat_d.items():
            liveness_info[f_name] = {}
            for block in func['blocks']:
                bid = self.translate_block_id(block['id'])
                block_liveness_info = block['liveness']
                liveness_info[f_name][bid] = block_liveness_info

        return liveness_info

    def translate_liveness_block(self, blockid, liveness_block):
        """ Generates the string Coq representation of a block
            | 0%nat => Some (EVMLiveness.list_to_set [], EVMLiveness.list_to_set [ 0%nat ] )
        """
        template = "\n         | {} => Some (EVMLiveness.list_to_set [ {} ], EVMLiveness.list_to_set [ {} ])"
        tr_blockid = f"{blockid}%nat"
        tr_liveness_input = "; ".join(map(lambda x: self.translate_var(x), liveness_block['in']))
        tr_liveness_output = "; ".join(map(lambda x: self.translate_var(x), liveness_block['out']))
        return template.format(tr_blockid, tr_liveness_input, tr_liveness_output)

    def translate_liveness_func(self, fname, liveness):
        """ Generates the string Coq representation of a function liveness """
        template = '''"{}" => Some (
      fun blockid =>
         match blockid with {}
         | _ => None
         end )'''
        tr_blocks = []
        for blockid, liveness_block in liveness.items():
            tr_blocks.append(self.translate_liveness_block(blockid, liveness_block))
        tr_blocks_str = "         ".join(tr_blocks)
        return template.format(fname, tr_blocks_str)

    def translate_liveness_info(self):
        """ Generates the string Coq representation of the liveness information in the function's blocks """
        template = """Definition liveness_info : FunctionName.t -> option EVMLiveness.fun_live_info_t :=
fun fname =>
   match fname with 
   | {}
   | _ => None
   end."""
        liveness_info = self.extract_liveness_info()
        tr_funcs = []
        for fname, liveness in liveness_info.items():
            tr_funcs.append(self.translate_liveness_func(fname, liveness))
        tr_funcs_str = "\n   | ".join(tr_funcs)
        return template.format(tr_funcs_str)

    def translate_liveness_coq_file(self):
        template = """(* 
FORYU: Automatic translation for liveness analysis
Smart contract: {} 
Date: {}

Compile with:
$ coqc -R . FORYU filename.v

*)

Require Export FORYU.program.
Require Export FORYU.semantics.
Require Export FORYU.liveness.
Import ListNotations.

Module EVMLiveness := Liveness(EVMDialect).
Module EVMSmallStep := EVMLiveness.SmallStepD.
Module EVMSmartContract := EVMSmallStep.SmartContractD.
Module EVMFunction := EVMSmartContract.FunctionD.
Module EVMBlock := EVMFunction.BlockD.
Module EVMInstruction := EVMBlock.InstructionD.
Module EVMState := EVMSmallStep.StateD.

Section Translation.

{}

{}

(* Launches liveness check *)
Compute (EVMLiveness.check_smart_contract sc_tr liveness_info).

End Translation.
        """
        return template.format(self.sc_main_filename, datetime.now(), self.translate_smart_contract(),
                               self.translate_liveness_info())

    def translate_liveness_coq_file_out(self, path):
        with open(path, 'w', encoding='utf8') as f:
            f.write(self.translate_liveness_coq_file())


if __name__ == '__main__':
    """
    sc = JSON_Smart_Contract('constant_variables_standard_input.json_cfg.json')
    print(sc.sc_main_filename)
    pprint.pp(sc.flat_d)
    print('\n\n')
    print(sc.translate_smart_contract())
    pprint.pp(sc.extract_liveness_info())
    print(sc.translate_liveness_info())
    
    # sc = JSON_Smart_Contract('constant_variables_standard_input.json_cfg.json')
    # sc = JSON_Smart_Contract('function_modifier_standard_input.json_cfg.json')
    sc = JSON_Smart_Contract('arrays_in_constructors_standard_input.json_cfg.json')
    # print(sc.translate_liveness_coq_file())
    sc.translate_liveness_coq_file_out('../test_translation.v')    
    """
    if len(sys.argv) != 3:
        print(f'Usage: {sys.argv[0]} <json_file> <coq_file>')
    else:
        sc = JSON_Smart_Contract(sys.argv[1])
        sc.translate_liveness_coq_file_out(sys.argv[2])

