"""
Translates a JSON file containing the CFG of a smart contract to the Coq representation of the FORYU project
(https://github.com/costa-group/foryu/tree/main)
JSON are obtained using solc:
$ solc file_standard_input.json --standard-json --pretty-json > cfg.json
"""

import json
import pprint
import re
import sys
from datetime import datetime

"""
Layout of the JSON file
{
    'contracts':{
        'name.sol':{
          'entry'
            'yulCFGJson':{
                'entry1':{
                    'blocks': [],
                    'functions': {
                        'f1': ...
                        'f2': ...
                    } 
                },
                
                'entry2':{
                    'blocks': [],
                    'functions': {
                        'f1': ...
                        'f2': ...
                    } 
                } 
            } 
            ...
        }
    }
    
    'errors':...
}
"""


class JSON_Smart_Contract:

    def __init__(self, path):
        self.sc_main_filename, self.flat_d = self.process_json(path)
        self.liveness = {}

    def gen_name(self, prefix):
        """ Generates a name from the prefix """
        return "__".join(prefix).replace(".", "_")

    def process_blocks(self, blocks, prefix):
        """ Generates a main function from an objects blocks """
        if blocks:
            return {self.gen_name(prefix + ['entry']):
                        {'arguments': [],
                         'blocks': blocks,
                         'entry': blocks[0]['id'],
                         'numReturns': 0}
                    }
        return {}

    def process_object(self, d: dict, prefix: list):
        """ Extracts all the entries in an object (and recursively subobjects), generating functions for each one """
        r = {}
        for object_name in d:
            if object_name == 'type':
                continue

            subobj = d[object_name]['subObjects']
            if subobj:
                r.update(self.process_object(subobj, prefix + [object_name]))
            r.update(
                d[object_name]['functions'])  # TODO: Do we need to rename the functions in different objects? (prefix)
            blocks = d[object_name]['blocks']
            if blocks:
                r.update(self.process_blocks(blocks, prefix + [object_name]))

        return r

    def process_json(self, path):
        """ Processes a JSON file as generated by solc and generates a flat dictionary of function definitions """
        with open(path, 'r', encoding="utf-8") as f:
            data = json.load(f)

        scs = data['contracts']
        flat_d = {}
        sc_main_filename = None
        for sc_filename in scs:
            sc = scs[sc_filename]
            if not sc_main_filename:
                sc_main_filename = sc_filename
            for comp in sc:
                yul_cfg = sc[comp]['yulCFGJson']
                assert yul_cfg['type'] == 'Object'
                flat_d.update(self.process_object(yul_cfg, [sc_filename, comp]))

        return sc_main_filename, flat_d

    def translate_block_id(self, block_id):
        """ Extracts the block number from the string 'BlockN' """
        return int(block_id[5:])

    def is_var(self, var: str):
        m = re.match(r"^v([0-9]+)$", var)
        return m is not None

    def translate_var(self, var: str):
        """ Translates a variable like 'v0' into '0%nat' """
        m = re.match(r"^v([0-9]+)$", var)
        assert m is not None
        var_i = int(m[1])
        return f"{var_i}%nat"

    def is_constant(self, v: str):
        m = re.match(r"^0x[0-9A-Fa-f]+$", v)
        return m is not None

    def translatate_constant(self, v: str) -> str:
        """ Translates a constant value, remains the same """
        assert self.is_constant(v), f"{v} no es un valor"
        return v

    def translate_var_list(self, var_list):
        """ Returns a string with the Coq list of variable indices
            ["v0", "v1"]  --> "0%nat; 1%nat"
        """
        vars_i = []
        for var in var_list:
            var_i = int(var[1:])  # To check they are integers
            assert var_i >= 0
            vars_i.append(f"{var_i}%nat")
        return "; ".join(vars_i)

    def translate_var_constant_list(self, vc_list):
        """ Translate a list containing variables or constant values using
            * inl Variable
            * inr Constant
        """
        elements = []
        for vc in vc_list:
            if self.is_var(vc):
                elements.append(f"inl {self.translate_var(vc)}")
            else:
                elements.append(f"inr {self.translatate_constant(vc)}")
        return "; ".join(elements)

    def generate_phi(self, phis, entries):
        # TODO: FIXME
        assert not entries or phis, f"A block without entry information has phi_functions: {phis}"
        assert len(entries) in [0, 2], f"A block with more than 1 o >2 entries: {entries}"
        if len(entries) == 0:
            return "EVMBlock.PhiInfoD.empty"

        # 2 entries
        block0 = f"{self.translate_block_id(entries[0])}%nat"
        block1 = f"{self.translate_block_id(entries[1])}%nat"
        phi_d = {block0: [], block1: []}
        for phi in phis:
            # {"in": ["v18", "v23"], "op": "PhiFunction", "out": ["v24"]}
            assert len(phi['out']) == 1, f"PhiFunction with more than one out variable {phi}"
            dest_v = self.translate_var(phi['out'][0])
            [value_0, value_1] = self.translate_var_constant_list(phi['in']).split('; ')
            phi_d[block0].append(f"({dest_v}, {value_0})")
            phi_d[block1].append(f"({dest_v}, {value_1})")

        # Generate Coq text for PhiInfo
        coq_block0 = '; '.join(phi_d[block0])
        coq_block1 = '; '.join(phi_d[block1])
        trans = f"fun blockid => if BlockID.eqb blockid {block0} then [{coq_block0}] else if BlockID.eqb blockid {block1} then [{coq_block1}] else []"
        return trans

    def translate_exit_info(self, exit):
        # TODO: FIXME
        if exit['type'] in ['Terminated', "MainExit"]:
            return "EVMBlock.ExitInfoD.Terminated"
        elif exit['type'] == 'FunctionReturn':
            # JSON: { "returnValues": ["v10"], "type": "FunctionReturn" }
            # Coq:  ReturnBlock (return_values : list SimpleExprD.t) (* I believe they are always vars *)
            return f"EVMBlock.ExitInfoD.ReturnBlock {self.translate_var_constant_list(exit['returnValues'])}"
        elif exit['type'] == 'ConditionalJump':
            # JSON: {'cond': 'v2', 'targets': ['Block2', 'Block1'], 'type': 'ConditionalJump'}
            # Coq:  ConditionalJump (cond_var : YULVariable.t) (target_if_true : BlockID.t) (target_if_false : BlockID.t)
            var = self.translate_var(exit['cond'])
            assert len(exit['targets']) == 2
            target_true = self.translate_block_id(exit['targets'][0])
            target_false = self.translate_block_id(exit['targets'][1])
            return f"EVMBlock.ExitInfoD.ConditionalJump {var} {target_true}%nat {target_false}%nat"
        elif exit['type'] == 'Jump':
            # JSON: {'targets': [BlockID], 'type': 'Jump' }
            # Coq:  Jump (target : BlockID.t)
            assert len(exit['targets']) == 1, f"JUMP exit block with more than one target: {exit}"
            target = self.translate_block_id(exit['targets'][0])
            return f"EVMBlock.ExitInfoD.Jump {target}%nat"
        else:
            raise Exception(f'Exit_info not supported: <<{exit}>>')

    def translate_instruction(self, instruction):
        evm_opcode = {
            # TODO: FIXME
            #              | STOP
            'add': 'EVM_opcode.ADD',
            #              | SUB
            #              | MUL
            #              | DIV
            #              | SDIV
            #              | MOD
            #              | SMOD
            #              | EXP
            'not': 'EVM_opcode.NOT',
            'lt': 'EVM_opcode.LT',
            #              | GT
            #              | SLT
            'slt': 'EVM_opcode.SLT',
            #              | SGT
            'eq': 'EVM_opcode.EQ',
            #              | ISZERO
            'iszero': 'EVM_opcode.ISZERO',
            #              | AND
            #              | OR
            #              | XOR
            #              | BYTE
            #              | SHL
            'shr': 'EVM_opcode.SHR',
            #              | SAR
            #              | ADDMOD
            #              | MULMOD
            #              | SIGNEXTEND
            #              | KECCAK256
            #              | POP
            #              | MLOAD
            'mstore': 'EVM_opcode.MSTORE',
            #              | MSTORE8
            #              | SLOAD
            #              | SSTORE
            #              | TLOAD
            #              | TSTORE
            #              | MSIZE
            #              | GAS
            #              | ADDRESS
            #              | BALANCE
            #              | SELFBALANCE
            #              | CALLER
            'callvalue': 'EVM_opcode.CALLVALUE',
            'calldataload': 'EVM_opcode.CALLDATALOAD',
            'calldatasize': 'EVM_opcode.CALLDATASIZE',
            #              | CALLDATACOPY
            #              | CODESIZE
            'codecopy': 'EVM_opcode.CODECOPY',
            #              | EXTCODESIZE
            #              | EXTCODECOPY
            #              | RETURNDATASIZE
            #              | RETURNDATACOPY
            #              | MCOPY
            #              | EXTCODEHASH
            #              | CREATE
            #              | CREATE2
            #              | CALL
            #              | CALLCODE
            #              | DELEGATECALL
            #              | STATICCALL
            'return': 'EVM_opcode.RETURN',
            'revert': 'EVM_opcode.REVERT',
            #              | SELFDESTRUCT
            #              | INVALID
            #              | LOG0
            #              | LOG1
            #              | LOG2
            #              | LOG3
            #              | LOG4
            #              | CHAINID
            #              | BASEFEE
            #              | BLOBBASEFEE
            #              | ORIGIN
            #              | GASPRICE
            #              | BLOCKHASH
            #              | BLOBHASH
            #              | COINBASE
            #              | TIMESTAMP
            #              | NUMBER
            #              | DIFFICULTY  # obsolete from Paris, now uses PREVRANDAO
            #              | PREVRANDAO
            #              | GASLIMIT
            #
            'memoryguard': 'EVM_opcode.MEMORYGUARD',
            'datasize': 'EVM_opcode.DATASIZE',
            'dataoffset': 'EVM_opcode.DATAOFFSET',
        }
        # {'in': ['0x00', '0x00'], 'op': 'revert', 'out': []}
        #    Record t : Type := {
        #     input : list SimpleExprD.t;
        #     output : list YULVariable.t; (* Output variables *)
        #     op : (FunctionName.t + D.opcode_t) + aux_inst_t;
        # {| EVMInstruction.input := [inr 0x2; inr 0x0202];
        #    EVMInstruction.output := [ 1%nat ];
        #    EVMInstruction.op := inl (inr EVM_opcode.MUL) |}.

        if instruction['op'] == 'PhiFunction':
            raise ValueError('PhiFunctions should be removed before translating instructions')
        elif instruction['op'] == 'LiteralAssignment':
            instr = 'inr EVMInstruction.ASSIGN'
        elif instruction['op'] in evm_opcode:
            instr = f"inl (inr {evm_opcode[instruction['op']]})"
        else:
            print(f"opcode desconocido: {instruction['op']}", file=sys.stderr)
            instr = f"inl (inr EVM_opcode.ADD)"  # FIXME for function calls

        in_v = self.translate_var_constant_list(instruction['in'])
        out_v = self.translate_var_list(instruction['out'])

        return (f"                  {{| EVMInstruction.input := [ {in_v} ];\n"
                f"                      EVMInstruction.output := [ {out_v} ];\n"
                f"                      EVMInstruction.op := {instr}\n"
                f"                  |}}")

    def translate_instructions(self, instructions):
        return ";\n".join([self.translate_instruction(i) for i in instructions])

    def split_block(self, instructions):
        """ Split a list of instructions into PhiFunctions and real instructions """
        phi_functions = list(filter(lambda i: i['op'] == 'PhiFunction', instructions))
        instr = list(filter(lambda i: i['op'] != 'PhiFunction', instructions))
        return phi_functions, instr

    def translate_block(self, block):
        """ Generates a string representing a Coq block from a JSON block """
        template = """
                {{| EVMBlock.bid := {}%nat;
                   EVMBlock.phi_function := {};
                   EVMBlock.exit_info := {};
                   EVMBlock.instructions := [ 
    {}]
                |}}"""
        bid = self.translate_block_id(block['id'])
        phi_functions, instr = self.split_block(block['instructions'])
        phi_function = self.generate_phi(phi_functions, block.get('entries', []))
        exit_info = self.translate_exit_info(block['exit'])
        instructions = self.translate_instructions(instr)
        return template.format(bid, phi_function, exit_info, instructions)

    def translate_blocks(self, blocks):
        return ";".join([self.translate_block(b) for b in blocks])

    def translate_function(self, f_name, func):
        """ Generates the Coq representation of a function """
        template = """      {{| EVMFunction.name := "{}";
             EVMFunction.arguments := [{}];
             EVMFunction.num_outputs := {};
             EVMFunction.blocks := [
    {}
             ];
             EVMFunction.entry_block_id := {}%nat
          |}}"""
        blocks = self.translate_blocks(func['blocks'])
        arguments = self.translate_var_list(func['arguments'])
        num_outputs = func['numReturns']
        entry_block_id = self.translate_block_id(func['entry'])
        return template.format(f_name, arguments, num_outputs, blocks, entry_block_id)

    def translate_smart_contract(self):
        """Generates the Coq representation of a smart contract """
        template = """Definition sc_tr : EVMSmartContract.t :=
       {{| EVMSmartContract.name := "{}";
           EVMSmartContract.functions := [\n{}];
           EVMSmartContract.main := "{}" 
       |}}."""
        functs_coq = []
        entry_fname = None
        for f_name, func in self.flat_d.items():
            if not entry_fname:
                entry_fname = f_name
            functs_coq.append(self.translate_function(f_name, func))
        list_functs = ";\n".join(functs_coq)

        return template.format(self.sc_main_filename, list_functs, entry_fname)

    def extract_liveness_info(self):
        """ Collects all the liveness information from function's blocks """
        liveness_info = {}
        for f_name, func in self.flat_d.items():
            liveness_info[f_name] = {}
            for block in func['blocks']:
                bid = self.translate_block_id(block['id'])
                block_liveness_info = block['liveness']
                liveness_info[f_name][bid] = block_liveness_info

        return liveness_info

    def translate_liveness_block(self, blockid, liveness_block):
        """ Generates the string Coq representation of a block
            | 0%nat => Some (EVMLiveness.list_to_set [], EVMLiveness.list_to_set [ 0%nat ] )
        """
        template = "\n         | {} => Some (EVMLiveness.list_to_set [ {} ], EVMLiveness.list_to_set [ {} ])"
        tr_blockid = f"{blockid}%nat"
        tr_liveness_input = "; ".join(map(lambda x: self.translate_var(x), liveness_block['in']))
        tr_liveness_output = "; ".join(map(lambda x: self.translate_var(x), liveness_block['out']))
        return template.format(tr_blockid, tr_liveness_input, tr_liveness_output)

    def translate_liveness_func(self, fname, liveness):
        """ Generates the string Coq representation of a function liveness """
        template = '''"{}" => Some (
      fun blockid =>
         match blockid with {}
         | _ => None
         end )'''
        tr_blocks = []
        for blockid, liveness_block in liveness.items():
            tr_blocks.append(self.translate_liveness_block(blockid, liveness_block))
        tr_blocks_str = "         ".join(tr_blocks)
        return template.format(fname, tr_blocks_str)

    def translate_liveness_info(self):
        """ Generates the string Coq representation of the liveness information in the function's blocks """
        template = """Definition liveness_info : FunctionName.t -> option EVMLiveness.fun_live_info_t :=
fun fname =>
   match fname with 
   | {}
   | _ => None
   end."""
        liveness_info = self.extract_liveness_info()
        tr_funcs = []
        for fname, liveness in liveness_info.items():
            tr_funcs.append(self.translate_liveness_func(fname, liveness))
        tr_funcs_str = "\n   | ".join(tr_funcs)
        return template.format(tr_funcs_str)

    def translate_liveness_coq_file(self):
        template = """(* 
FORYU: Automatic translation for liveness analysis
Smart contract: {} 
Date: {}

Compile with:
$ coqc -R . FORYU filename.v

*)

Require Export FORYU.program.
Require Export FORYU.semantics.
Require Export FORYU.liveness.
Import ListNotations.

Module EVMLiveness := Liveness(EVMDialect).
Module EVMSmallStep := EVMLiveness.SmallStepD.
Module EVMSmartContract := EVMSmallStep.SmartContractD.
Module EVMFunction := EVMSmartContract.FunctionD.
Module EVMBlock := EVMFunction.BlockD.
Module EVMInstruction := EVMBlock.InstructionD.
Module EVMState := EVMSmallStep.StateD.

Section Translation.

{}

{}

(* Launches liveness check *)
Compute (EVMLiveness.check_smart_contract sc_tr liveness_info).

End Translation.
        """
        return template.format(self.sc_main_filename, datetime.now(), self.translate_smart_contract(),
                               self.translate_liveness_info())

    def translate_liveness_coq_file_out(self, path):
        with open(path, 'w', encoding='utf8') as f:
            f.write(self.translate_liveness_coq_file())


if __name__ == '__main__':
    """
    sc = JSON_Smart_Contract('constant_variables_standard_input.json_cfg.json')
    print(sc.sc_main_filename)
    pprint.pp(sc.flat_d)
    print('\n\n')
    print(sc.translate_smart_contract())
    pprint.pp(sc.extract_liveness_info())
    print(sc.translate_liveness_info())
    """
    # sc = JSON_Smart_Contract('constant_variables_standard_input.json_cfg.json')
    sc = JSON_Smart_Contract('function_modifier_standard_input.json_cfg.json')
    # sc = JSON_Smart_Contract('arrays_in_constructors_standard_input.json_cfg.json')
    # print(sc.translate_liveness_coq_file())
    sc.translate_liveness_coq_file_out("../test_translation.v")
